---
title: 包域 (Scope)
description: 深入了解 Scoped Package Tree 模型的高级特性：Scope 作用域控制与参数注入
---

import { FileTree, Aside, Badge } from '@astrojs/starlight/components';

Flake FHS 的子目录包兼容 nixpkgs 的 `by-name` 目录, 并在此基础上扩展了 `scope.nix` 提供了对 callPackage 的精细控制能力。

本文档详细介绍 `callPackage` 机制、如何通过 `scope.nix` 切换依赖集（如切换到 Python 环境），以及如何注入自定义参数（如 `inputs`）。

## 原理机制

Flake FHS 使用 Nix 的 `callPackage` 机制来构建软件包。

这里 `callPackage` 的通用的模式是:

```nix
some-package = scopePkgs.callPackage /path/to/some-package/package.nix extraArgs
```

一般来说, scopePkgs 使用来自 nixpkgs 的顶层包 (pkgs) 即可, 这也是 nixpkgs/pkgs/by-name 的标准做法.

但, 有时候我们又想针对性地指定 `scopePkgs`, 怎么办呢?  就可以用 Flake FHS 提供的 `scope.nix` 文件机制.

## scope.nix 配置

`scope.nix` 文件用于配置当前目录及其子目录的 `callPackage` 上下文。

<FileTree>
- pkgs/
  - python/
    - scope.nix          <Badge text="定义局部作用域" variant="default" size="small" />
    - my-python-pkg/
      - package.nix
</FileTree>

<Aside type="note" title="作用范围">
`scope.nix` 会影响**同级目录**中的所有包以及**所有子目录**。
</Aside>

### 文件格式

`scope.nix` 也是一个函数，接收全局参数 (systemContext) 并返回配置对象：

```nix
{ pkgs, inputs, ... }:
{
  scope = ...;
  args = ...;
}
```

### 配置项说明

| 属性 | 说明 | 行为 |
| :--- | :--- | :--- |
| **`scope`** | 指定用于 `callPackage` 的基础包集 (Base Scope) | **替换 (Replace)** <br/>如果指定，则替换父级 Scope（但仍继承父级 `args`）。常见用途是切换语言环境（如 `pkgs.python3Packages`）。 |
| **`args`** | 注入到 `callPackage` 的额外参数 | **合并 (Merge)** <br/>与父级 `args` 合并。用于注入公共依赖、配置开关或 `inputs`。 |

## 常见用法

### 1. 注入全局参数 (如 inputs)

默认情况下，`callPackage` 的作用域仅包含 `nixpkgs` 中的包。如果你的包需要访问全局参数（如 `self`, `inputs`, `lib`），你需要通过 `scope.nix` 显式注入它们。

`pkgs/scope.nix` (通常在根目录或特定子目录):

```nix
{ inputs, self, ... }:
{
  # 将 inputs 和 self 注入到 args 中
  # 这样同级及子目录下的包都可以通过参数接收它们
  args = { inherit inputs self; };
}
```

然后在包定义中使用：

```nix
{ stdenv, inputs, ... }: # 直接在参数中接收 inputs
stdenv.mkDerivation {
  pname = "my-package";
  version = inputs.self.shortRev or "dirty";
  # ...
}
```

### 2. 切换语言环境 (如 Python)

切换到特定语言的包集环境，可以简化特定语言应用的打包。

`pkgs/my-tool/scope.nix`:
```nix
{ pkgs, ... }:
{
  # 替换模式：将 Base Scope 切换为 Python 3.11 包集
  # 下级文件中的 callPackage 将从 python311Packages 中查找依赖
  scope = pkgs.python311Packages;
}
```

`pkgs/my-tool/app.nix`:
```nix
# 这里可以直接请求 buildPythonApplication 以及 pandas, requests 等 Python 库
# 而不需要写 python3Packages.pandas
{ buildPythonApplication, pandas, requests, ... }:

buildPythonApplication {
  pname = "my-data-tool";
  # ...
  propagatedBuildInputs = [ pandas requests ];
}
```

### 3. 定义目录级变量

你可以在 `scope.nix` 中定义一些共享变量或辅助函数，供该目录下的所有包使用。

`pkgs/internal/scope.nix`:
```nix
{ pkgs, ... }:
{
  args = {
    # 定义一个共享版本号
    commonVersion = "1.2.3";
    # 定义一个开关
    enableDebug = true;
  };
}
```

`pkgs/internal/backend.nix`:
```nix
{ stdenv, commonVersion, enableDebug, ... }:
stdenv.mkDerivation {
  pname = "backend";
  version = commonVersion;
  # ...
}
```

## 继承规则详解

当目录层级嵌套时，`scope.nix` 的配置遵循以下继承规则：

1.  **Scope (包集)**:
    *   若当前层级未定义 `scope`：沿用父级 Scope。
    *   若当前层级定义了 `scope`：**替换**父级 Scope 为新集合。

2.  **Args (参数)**:
    *   始终是**合并**关系。
    *   `Final Args = Root Args + ... + Parent Args + Current Args`。
    *   如果同名参数冲突，子层级的值覆盖父层级。

这种设计确保了你可以在顶层注入通用参数（如 `inputs`），而在底层目录灵活切换特定的构建环境。
