---
title: 软件包 (Packages)
description: 学习如何在 pkgs/ 目录中定义软件包，使用 Scoped Package Tree 模型构建项目特有的包。
---

import { FileTree, Aside, Badge } from '@astrojs/starlight/components';

Flake FHS 的 **Scoped Package Tree** 模型将 `pkgs/` 目录直接映射为 `packages.<system>.<name>`。

本文档介绍如何在 `pkgs/` 目录中添加软件包。

## <span id="pkgs">基本用法</span>

`pkgs/` 目录用于存放项目自身的软件包定义。

### 目录结构

你可以直接在 `pkgs/` 下创建 `.nix` 文件 (单文件包)，或者创建一个包含 `package.nix` 的子目录 (子目录包)。

<FileTree>
- pkgs/
  - hello.nix            <Badge text="单文件包 (顶层 .nix 文件)" variant="default" size="small" />
  - complex-app/         <Badge text="子目录包" variant="default" size="small" />
    - package.nix        <Badge text="入口文件" variant="default" size="small" />
    - src/               <Badge text="辅助文件" variant="default" size="small" />
</FileTree>

### 编写软件包

在 Flake FHS 中，软件包定义完全遵循 **Nixpkgs 标准规范**。它就是一个标准的 Nix 函数（通常称为 `callPackage` 模式），接收依赖项作为参数，并返回一个 Derivation。这种标准化的设计意味着你可以轻松地将代码贡献给上游 nixpkgs。

**示例：定义一个简单的 Hello World 包**

`pkgs/hello.nix`:

```nix
{ stdenv, fetchFromGitHub, lib }:

stdenv.mkDerivation rec {
  pname = "hello";
  version = "2.12.1";

  src = fetchFromGitHub {
    owner = "editorconfig";
    repo = "editorconfig-core-c";
    rev = "v${version}";
    sha256 = "0znh7c2j0... (hash)";
  };

  installPhase = ''
    mkdir -p $out/bin
    cp editorconfig $out/bin/
  '';

  meta = with lib; {
    description = "EditorConfig core library written in C";
    homepage = "https://editorconfig.org/";
    license = licenses.bsd2;
  };
}
```

### 自动依赖注入

注意上面的例子中，函数参数 `{ stdenv, fetchFromGitHub, lib }` 并没有显式导入。

这是因为 Flake FHS 会自动从 `nixpkgs` 中查找并注入这些依赖。你只需要声明你需要的包名即可。

<Aside type="tip">
这种机制称为 `callPackage`。它是 Nix 生态中最核心的依赖管理模式。
</Aside>

## 高级用法

如果你需要：
*   切换构建环境（例如使用 `python3Packages` 而不是默认的 `pkgs`）。
*   注入全局参数（如 `inputs`、`self`）。
*   自定义目录级变量。

请参考高级指南：[包域 (Scope)](/zh-cn/manual-pkgs-scope)。
