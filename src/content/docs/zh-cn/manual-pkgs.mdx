---
title: 软件包 (Packages)
description: 深入了解 Scoped Package Tree 模型，包括 Scope 作用域、callPackage 机制和依赖注入
---

import { FileTree, Aside, Badge } from '@astrojs/starlight/components';

Flake FHS 采用统一的 **"Scoped Package Tree"** 模型来处理软件包 (`pkgs`)、应用程序 (`apps`)、开发环境 (`shells`) 和检查 (`checks`)。

本文档详细介绍这一核心模型，它是理解整个框架构建逻辑的基础。

## <span id="pkgs">pkgs/ - 软件包</span>

`pkgs/` 目录用于定义项目特有的软件包，映射为 `packages.<system>.<name>`。它是 Scoped Package Tree 模型的标准实现。

### 目录结构

遵循类似 `nixpkgs` 的 `by-name` 结构，同时支持单文件定义：

<FileTree>

- pkgs/
  - hello.nix            <Badge text="简单包 (文件模式)" variant="default" size="small" />
  - complex-app/         <Badge text="复杂包 (目录模式)" variant="default" size="small" />
    - package.nix        <Badge text="必须包含此文件" variant="default" size="small" />
    - src/               <Badge text="辅助文件" variant="default" size="small" />
  - group/               <Badge text="包组 (普通目录)" variant="default" size="small" />
    - scope.nix          <Badge text="定义局部作用域" variant="default" size="small" />
    - utils.nix          <Badge text="辅助文件" variant="default" size="small" />
    - core/
      - package.nix      <Badge text="子目录中的包" variant="default" size="small" />

</FileTree>

### Scope 与 callPackage

Flake FHS 使用 Nix 的 `callPackage` 机制来构建软件包。所有包定义（无论是 `.nix` 文件还是 `package.nix`）都通过 `callPackage` 构建，因此你可以直接声明所需的依赖。

#### Scope (作用域)

`scope.nix` 文件用于配置 `callPackage` 所使用的 **Scope (上下文包集)**。

<Aside type="note" title="作用范围">
`scope.nix` 会影响**同级目录**中的所有包以及**所有子目录**。
</Aside>

*   **约定格式**: `{ pkgs, inputs, ... }: { scope = ...; args = ...; }`

#### 参数说明

*   **scope**: 指定用于执行 `callPackage` 的基础包集 (Base Scope)。
    *   例如：`pkgs.python3Packages`。
    *   如果指定了 `scope`，则会**替换**父级的 scope（切断继承）。
    *   如果未指定，则默认**继承**父级的 scope。
*   **args**: 注入到 `callPackage` 的额外参数。
    *   这些参数会作为 **第二个参数** 传递给 `callPackage`。
    *   最终，它们可以作为参数直接传递给包定义函数。

#### 参数注入

默认情况下，`callPackage` 的作用域仅包含 `pkgs`。如果你的包需要访问全局参数（如 `self`, `inputs`, `lib`），你需要通过 `scope.nix` 显式注入它们。

例如，注入 `self` 和 `inputs`：

`pkgs/scope.nix`:

```nix
{ inputs, self, ... }:
{
  # 将 inputs 和 self 注入到 args 中
  # 这样同级及子目录下的包都可以通过参数接收它们
  args = { inherit inputs self; };
}
```

然后你就可以在包定义中使用它们：

```nix
{ stdenv, inputs, ... }:
stdenv.mkDerivation {
  # ... 使用 inputs.nixpkgs ...
  pname = "my-package";
  version = inputs.self.shortRev or "dirty";
}
```

#### 继承规则

*   **只提供 `args`**: **合并**。继承父级 args，并与当前 args 合并。适合注入公共依赖或配置。
*   **提供 `scope`**: **替换**。使用提供的 `scope` 作为新基础。适合切换语言生态（如切换到 Python 环境）。注意：即使替换了 Scope，父级目录定义的 `args` 依然会被继承（除非被同名参数覆盖）。

### 示例

#### 示例 1：Python 应用程序 (目录级 Scope)

切换到 Python 包集环境，以便直接访问 python 库。

<FileTree>

- pkgs/
  - my-tool/
    - scope.nix      <Badge text="切换到 Python 环境" variant="default" size="small" />
    - app.nix        <Badge text="主程序" variant="default" size="small" />
    - helper.nix     <Badge text="辅助库" variant="default" size="small" />

</FileTree>

`pkgs/my-tool/scope.nix`:
```nix
{ pkgs, ... }:
{
  # 替换模式：将 Base Scope 切换为 Python 3.11 包集
  # 下级文件中的 callPackage 将从 python311Packages 中查找依赖
  scope = pkgs.python311Packages;
}
```

`pkgs/my-tool/app.nix`:
```nix
# 这里可以直接请求 buildPythonApplication 以及 pandas, requests 等 Python 库
{ buildPythonApplication, pandas, requests, ... }:

buildPythonApplication {
  pname = "my-data-tool";
  version = "0.1.0";
  # ...
  propagatedBuildInputs = [ pandas requests ];
}
```

#### 示例 2：Per-Package 参数注入

为特定包注入版本号或构建开关。

`pkgs/my-app/scope.nix`:
```nix
{ inputs, ... }: {
  args = {
    # 注入 git commit hash 作为版本号
    revision = inputs.self.shortRev or "dirty";
    enableGui = true;
  };
}
```

`pkgs/my-app/package.nix`:
```nix
{ stdenv, revision, enableGui }: # 直接接收注入的参数

stdenv.mkDerivation {
  pname = "my-app";
  version = revision;
  
  buildFlags = lib.optional enableGui "--enable-gui";
  # ...
}
```
